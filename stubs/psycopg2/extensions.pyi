"""Type stubs for psycopg2.extensions"""

from typing import Any, Optional, Dict, List, Union, Tuple, Iterator, Type, Callable

class connection:
    """PostgreSQL connection object"""
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def close(self) -> None: ...
    def commit(self) -> None: ...
    def rollback(self) -> None: ...
    def cursor(self, name: Optional[str] = ..., cursor_factory: Optional[Type[cursor]] = ...) -> cursor: ...
    def set_isolation_level(self, level: int) -> None: ...
    def set_client_encoding(self, encoding: str) -> None: ...
    def get_transaction_status(self) -> int: ...
    def get_parameter_status(self, parameter: str) -> Optional[str]: ...
    def get_backend_pid(self) -> int: ...
    def get_dsn_parameters(self) -> Dict[str, str]: ...
    def cancel(self) -> None: ...
    def reset(self) -> None: ...
    
    # Properties
    closed: int
    encoding: str
    notices: List[str]
    notifies: List[Any]
    dsn: str
    status: int
    
    # Context manager support
    def __enter__(self) -> 'connection': ...
    def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None: ...

class cursor:
    """PostgreSQL cursor object"""
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def close(self) -> None: ...
    def execute(self, query: str, vars: Optional[Union[Tuple[Any, ...], Dict[str, Any]]] = ...) -> None: ...
    def executemany(self, query: str, vars_list: List[Union[Tuple[Any, ...], Dict[str, Any]]]) -> None: ...
    def fetchone(self) -> Optional[Tuple[Any, ...]]: ...
    def fetchmany(self, size: Optional[int] = ...) -> List[Tuple[Any, ...]]: ...
    def fetchall(self) -> List[Tuple[Any, ...]]: ...
    def callproc(self, procname: str, parameters: Optional[Tuple[Any, ...]] = ...) -> Optional[Tuple[Any, ...]]: ...
    def mogrify(self, operation: str, parameters: Optional[Union[Tuple[Any, ...], Dict[str, Any]]] = ...) -> bytes: ...
    def setinputsizes(self, sizes: Tuple[Any, ...]) -> None: ...
    def setoutputsize(self, size: int, column: Optional[int] = ...) -> None: ...
    def copy_from(self, file: Any, table: str, sep: str = ..., null: str = ..., size: int = ..., columns: Optional[Tuple[str, ...]] = ...) -> None: ...
    def copy_to(self, file: Any, table: str, sep: str = ..., null: str = ..., columns: Optional[Tuple[str, ...]] = ...) -> None: ...
    def copy_expert(self, sql: str, file: Any, size: int = ...) -> None: ...
    def scroll(self, value: int, mode: str = ...) -> None: ...
    def nextset(self) -> Optional[bool]: ...
    
    # Properties
    description: Optional[Tuple[Tuple[str, Any, Optional[int], Optional[int], Optional[int], Optional[int], Optional[bool]], ...]]
    rowcount: int
    arraysize: int
    itersize: int
    lastrowid: Optional[int]
    query: Optional[bytes]
    statusmessage: Optional[str]
    cast: Callable[[int, str], Any]
    tzinfo_factory: Optional[Callable[[Optional[int]], Any]]
    connection: connection
    name: Optional[str]
    scrollable: Optional[bool]
    withhold: bool
    
    # Iterator support
    def __iter__(self) -> Iterator[Tuple[Any, ...]]: ...
    def __next__(self) -> Tuple[Any, ...]: ...
    
    # Context manager support
    def __enter__(self) -> 'cursor': ...
    def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None: ...

# Transaction isolation levels
ISOLATION_LEVEL_AUTOCOMMIT: int
ISOLATION_LEVEL_READ_UNCOMMITTED: int
ISOLATION_LEVEL_READ_COMMITTED: int
ISOLATION_LEVEL_REPEATABLE_READ: int
ISOLATION_LEVEL_SERIALIZABLE: int

# Connection status constants
STATUS_SETUP: int
STATUS_READY: int
STATUS_BEGIN: int
STATUS_SYNC: int
STATUS_ASYNC: int
STATUS_PREPARED: int

# Transaction status constants
TRANSACTION_STATUS_IDLE: int
TRANSACTION_STATUS_ACTIVE: int
TRANSACTION_STATUS_INTRANS: int
TRANSACTION_STATUS_INERROR: int
TRANSACTION_STATUS_UNKNOWN: int

# Poll constants
POLL_OK: int
POLL_READ: int
POLL_WRITE: int
POLL_ERROR: int

def adapt(obj: Any) -> Any: ...
def register_adapter(typ: Type[Any], callable: Callable[[Any], Any]) -> None: ...
def register_type(typ: Any, conn_or_curs: Optional[Union[connection, cursor]] = ...) -> None: ...
def new_type(oids: Tuple[int, ...], name: str, adapter: Callable[[str, cursor], Any]) -> Any: ...
def new_array_type(oids: Tuple[int, ...], name: str, base_caster: Any) -> Any: ...
def register_uuid(oids: Optional[Tuple[int, ...]] = ..., conn_or_curs: Optional[Union[connection, cursor]] = ...) -> None: ...
